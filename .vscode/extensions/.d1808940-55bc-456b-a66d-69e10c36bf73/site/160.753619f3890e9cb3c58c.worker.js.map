{"version":3,"sources":["../node_modules/prismjs/components/prism-markup-templating.js"],"names":["Prism","languages","Object","defineProperties","buildPlaceholders","value","env","language","placeholderPattern","replaceFilter","tokenStack","code","replace","match","i","length","indexOf","toUpperCase","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","index","replacement","before","substring","middle","Token","tokenize","after","filter","v","Array","prototype","splice","apply","concat"],"mappings":"2CAAAA,MAAAC,UAAA,wBACAC,OAAAC,iBAAAH,MAAAC,UAAA,sBACAG,kBAAA,CAIAC,MAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACAH,EAAAC,eAIAD,EAAAI,WAAA,GACAJ,EAAAK,KAAAL,EAAAK,KAAAC,QAAAJ,EAAA,SAAAK,GACA,uBAAAJ,MAAAI,GACA,OAAAA,EAKA,IAFA,IAAAC,EAAAR,EAAAI,WAAAK,QAEA,IAAAT,EAAAK,KAAAK,QAAA,MAAAT,EAAAU,cAAAH,EAAA,UACAA,EAKA,OADAR,EAAAI,WAAAI,GAAAD,EACA,MAAAN,EAAAU,cAAAH,EAAA,QAGAR,EAAAY,QAAAlB,MAAAC,UAAAkB,UAGAC,qBAAA,CAEAf,MAAA,SAAAC,EAAAC,GACA,GAAAD,EAAAC,cAAAD,EAAAI,WAAA,CAKAJ,EAAAY,QAAAlB,MAAAC,UAAAM,GACA,IAAAc,EAAA,EACAC,EAAApB,OAAAoB,KAAAhB,EAAAI,aAEA,SAAAa,EAAAC,GACA,KAAAH,GAAAC,EAAAP,QAIA,QAAAD,EAAA,EAAuBA,EAAAU,EAAAT,OAAmBD,IAAA,CAC1C,IAAAW,EAAAD,EAAAV,GAEA,qBAAAW,KAAAC,SAAA,kBAAAD,EAAAC,QAAA,CACA,IAAAC,EAAAL,EAAAD,GACAO,EAAAtB,EAAAI,WAAAiB,GACAE,EAAA,kBAAAJ,MAAAC,QACAI,EAAAD,EAAAb,QAAA,MAAAT,EAAAU,cAAAU,EAAA,OAEA,GAAAG,GAAA,KACAT,EACA,IAGAU,EAHAC,EAAAH,EAAAI,UAAA,EAAAH,GACAI,EAAA,IAAAlC,MAAAmC,MAAA5B,EAAAP,MAAAoC,SAAAR,EAAAtB,EAAAY,QAAAX,GAAA,YAAAA,EAAAqB,GACAS,EAAAR,EAAAI,UAAAH,GAAA,MAAAvB,EAAAU,cAAAU,EAAA,OAAAZ,QAkBA,GAfAiB,GAAAK,EAIAd,EAHAQ,EAAA,CAAAC,EAAAE,EAAAG,GAAAC,OAAA,SAAAC,GACA,QAAAA,KAIAR,EAAAG,EAGA,kBAAAT,EACAe,MAAAC,UAAAC,OAAAC,MAAAnB,EAAA,CAAAV,EAAA,GAAA8B,OAAAb,IAEAN,EAAAC,QAAAK,EAGAV,GAAAC,EAAAP,OACA,YAGWU,EAAAC,SAAA,kBAAAD,EAAAC,SACXH,EAAAE,EAAAC,UAKAH,CAAAjB,EAAAkB","file":"160.753619f3890e9cb3c58c.worker.js","sourcesContent":["Prism.languages['markup-templating'] = {};\nObject.defineProperties(Prism.languages['markup-templating'], {\n  buildPlaceholders: {\n    // Tokenize all inline templating expressions matching placeholderPattern\n    // If the replaceFilter function is provided, it will be called with every match.\n    // If it returns false, the match will not be replaced.\n    value: function value(env, language, placeholderPattern, replaceFilter) {\n      if (env.language !== language) {\n        return;\n      }\n\n      env.tokenStack = [];\n      env.code = env.code.replace(placeholderPattern, function (match) {\n        if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n          return match;\n        }\n\n        var i = env.tokenStack.length; // Check for existing strings\n\n        while (env.code.indexOf('___' + language.toUpperCase() + i + '___') !== -1) {\n          ++i;\n        } // Create a sparse array\n\n\n        env.tokenStack[i] = match;\n        return '___' + language.toUpperCase() + i + '___';\n      }); // Switch the grammar to markup\n\n      env.grammar = Prism.languages.markup;\n    }\n  },\n  tokenizePlaceholders: {\n    // Replace placeholders with proper tokens after tokenizing\n    value: function value(env, language) {\n      if (env.language !== language || !env.tokenStack) {\n        return;\n      } // Switch the grammar back\n\n\n      env.grammar = Prism.languages[language];\n      var j = 0;\n      var keys = Object.keys(env.tokenStack);\n\n      var walkTokens = function walkTokens(tokens) {\n        if (j >= keys.length) {\n          return;\n        }\n\n        for (var i = 0; i < tokens.length; i++) {\n          var token = tokens[i];\n\n          if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n            var k = keys[j];\n            var t = env.tokenStack[k];\n            var s = typeof token === 'string' ? token : token.content;\n            var index = s.indexOf('___' + language.toUpperCase() + k + '___');\n\n            if (index > -1) {\n              ++j;\n              var before = s.substring(0, index);\n              var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar, language), 'language-' + language, t);\n              var after = s.substring(index + ('___' + language.toUpperCase() + k + '___').length);\n              var replacement;\n\n              if (before || after) {\n                replacement = [before, middle, after].filter(function (v) {\n                  return !!v;\n                });\n                walkTokens(replacement);\n              } else {\n                replacement = middle;\n              }\n\n              if (typeof token === 'string') {\n                Array.prototype.splice.apply(tokens, [i, 1].concat(replacement));\n              } else {\n                token.content = replacement;\n              }\n\n              if (j >= keys.length) {\n                break;\n              }\n            }\n          } else if (token.content && typeof token.content !== 'string') {\n            walkTokens(token.content);\n          }\n        }\n      };\n\n      walkTokens(env.tokens);\n    }\n  }\n});"],"sourceRoot":""}